# 회원 관리 예제

### 비즈니스 요구사항 정리
1. 데이터 : 회원 ID, 이름
2. 기능 : 회원 등록, 조회
3. 아직 데이터 저장소가 선정되지 않음 (가상 시나리오)

### 일반적인 웹 어플리케이션 계층 구조
1. 컨트롤러 : 웹 MVC의 컨트롤러 역할
2. 서비스 : 도메인 가지고 핵심 비즈니스 로직을 구현한 계층
   ex) 회원은 중복 가입이 안 된다 등등
3. 리포지토리 : 도메인 객체를 DB에 저장하고 관리
4. 도메인 : 비즈니스 도메인 객체
   ex) 회원, 주문, 쿠폰 등등 => 주로 DB에 저장되고 관리됨
   
### 클래스 의존관계
MemberService -> MemberRepository(interface로 설계)
// MemoryMemberRepository라는 구현체 만듦

- 아직 데이터 저장소가 선정되지 않아, 인터페이스로 만들어 구현 클래스를 나중에 변경할 수 있도록 함
- 데이터 저장소는 RDB, NoSQL 등 다양한 저장소를 고민중인 상황
- 초기 개발 단계에서는 구현체로 가벼운 메모리기반 데이터 저장소만 사용

### option + enter 쳐서 자동 import 가능


### 회원 repository 테스트 케이스 
방법1. main 메서드 실행
방법2. 웹 애플리케이션의 controller를 통해 실행
=> 1, 2는 오래걸리고, 반복 실행 어렵고, 여러 테스트 한 번에 실행도 어려움

방법3. JUnit 프레임워크로 테스트를 실행 => 위의 문제 해결

### DI
- Dependency Injection : 의존성 주입
- 필요한 객체를 직접 만들지 않고, 외부에서 주입받는 방식
- 필드 주입, setter 주입, 생성자 주입 (3가지)

1. 필드 주입
   : 필드에 private 변수 앞에 @Autowired // 별로 안 좋음 (그냥 변수여서 중간에 변경할 수가 없으니까)
2. setter 주입
   : setter함수 위에 @Autowired 넣어주면 됨
   setter는 한 번 설정하면 중간에 바꿀 일이 없어 굳이 public으로 할 필요가 없는데,
   setter 주입을 쓰기 위해서는 얠 public으로 바꿔야하는 단점이 있다
3. 생성자 주입
   : 위에서 짠 코드처럼 생성자 위에 @Autowired 해주고, 생성자를 통해 bean에서 가져옴
   => 가장 권장됨

### Autowired
: 스프링이 관리하는 객체에서만 동작한다. 그냥 내가 따로 만든 객체에서는 동작하지 않는다.
   => 그래서 @ ~~ 를 쓰는 것

