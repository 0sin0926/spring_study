# 스프링 웹 개발 기초
### 방식
1. 정적 컨텐츠 : 파일을 웹브라우저에 그대로 내려줌 // welcome page
2. MVC와 템플릿 엔진 // 서버에성 프로그래밍 -> model, view, controller
3. API

### 1. 정적 컨텐츠
- main->java->resources->static 폴더에 hello-static.html이라는 파일을 만들고 실행하면,
=> 코드 그대로 반환이 됨 // 추가 프로그래밍은 불가

- 원리
웹브라우저에서 8080/hello-static.html 입력
-> 내장 톰캣서버가 스프링 컨테이너에서 관련 컨테이너 있는지 찾아 // 컨테이너가 우선
-> 없으면 resource에서 그런 파일이 있는지를 확인
-> 그 파일 읽어서 그대로 반환

### 2. mvc와 템플릿 엔진
MVC = Model, View, Controller
- view : 화면에 보이는 것
- controller : 비즈니스 로직, 서버 뒤에 있는 거
- model : 화면에 필요한 걸 담아 화면쪽에 필요한 걸 넘겨줌

=> 이렇게 쪼개는 이유 : 관심사를 분리하고, 코드의 유지보수성을 높이기 위 // 코드가 체계적이고 관리 쉬워짐

- 원리
똑같이 웹브라우저에서 주소를 내장 톰캣서버로 넘김
-> spring한테 던지면 helloController에 매핑이 돼있음을 확인함
-> 그 코드 안에 있는 hello-templte 리턴 // model(name:spring)
-> viewResolver가 templates/hello-template.html을 찾아서 타임리프 템플릿 엔진에 넘김
- 타임리프가 HTML로 변환한 파일을 웹브라우저에 넘김

### API
- 내가 return값에 입력한 걸 그대로 내려보냄
- view 같은 걸 거치지 않고 간다. => template에 파일 안 만듦

=> API 사용 이유 : 클라이언트(앱,웹)에 구조화된 데이터를 전달하기 위해 (JSON 형식)

- JSON : { key : value }로 이루어진 구조
  // 리턴값으로 객체를 넘기면 위와 같이 나옴
- JSON 방식
1. @ResponseBody // http의 body에 밑의 내용을 넣겠다
2. return hello;(객체 리턴)
=> 이렇게 두 개 쓰면 JSON 방식으로 진행됨

- 원리
- mvc처럼 웹 브라우저에서 helloController까지 도착했는데 @ResponseBody를 만남
//viewResolver한테 던져서 매핑되는 template을 찾는 게 아니라, http body에 바로 넘겨버림
-> @ResponseBody를 만나면 httpMessageConverter가 작동함
-> 문자열이면 그대로 넘기고(stringConverter), 객체가 오면 JSON 방식으로 데이터를 만들어서 http 응답으로 반환함(JsonConverter)
-> 그렇게 convert한 걸 웹브라우저에 넘긴다

- @ResponseBody를 사용하면 ..
1. HTTP의 BODY에 문자 내용을 직접 반환
2. viewResolver 대신에 HttpMessageConverter가 동작
3. - 기본 문자처리 : StringHttpMessageConverter
   - 기본 객체처리 : MappingJackson2HttpMessageConverter // Jackson = 객체를 JSON으로 바꿔주는 라이브러리


- 최종 정리
1. 정적 컨텐츠 : 파일을 그대로 내림
2. mvc와 템플릿 엔진 : 템플릿 엔진을 model, view, controller 방식으로 쪼갠 뒤, view를 템플릿 엔진을 통해 html을 랜더링한 후, 그걸 client에게 전달함
3. API : 객체를 반환하는 것 (converter를 통해 JSON 방식으로 변경)
